#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import argparse
import glob
import io
import logging
import logging.handlers
import os
import subprocess
import sys
import time
import traceback

from argparse import RawTextHelpFormatter
from configparser import NoOptionError
from configparser import NoSectionError
from shutil import which
from textwrap import dedent

# Defining Script Name
module_name = os.path.basename(sys.argv[0])

# Defining Script Current Version
module_version = "1.0.0"
original_busco_module_version = "4.0.0"

# Defining_Script_Initial_Version_Data (date '+DATE:%Y/%m/%d%tTIME:%R')
version_date_initial = "DATE:2024/04/05	TIME:09:27"

# Defining_Script_Current_Version_Data (date '+DATE:%Y/%m/%d%tTIME:%R')
version_date_current = "DATE:2024/04/05	TIME:09:28"

copyright = dedent(f"""
Original Code Link:    https://gitlab.com/ezlab/busco/
Original Code Version: {original_busco_module_version}

Licensed under the MIT license.

This program was modified from code initially generated by Evgeny Zdobnov (ez@ezlab.org),
and as such it inherits it's original MIT License.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See LICENSE.md file for details.

You should have received a copy of the MIT License along with this program, If not,
see: https://opensource.org/license/MIT
""")

authors = dedent("""
Author current release:  Rodolfo Aramayo
                           WORK_EMAIL:     raramayo@tamu.edu
                           PERSONAL_EMAIL: rodolfo@aramayo.org
Author original release: Mathieu Seppey
""")

usage = dedent(f"""
MODULE__NAME:       {module_name}
MODULE_VERSION:     {module_version}
MODULE_SYNOPSIS:    This module produces a graphic summary for BUSCO runs based on short summary files

This tool uses the short summary files produces by the Busco tool (https://busco.ezlab.org/ and https://gitlab.com/ezlab/busco/-/tree/master),
and ggplot2 (2.2.0+) (https://ggplot2.tidyverse.org/), to produce and execute a file containing R code needed to produce a figure in either:
    'jpeg' (default), 'png', or 'tiff' formats.

This tool assumes your system is able to run R. It also uses the following R libraries:

    dplyr (https://cran.r-project.org/web/packages/dplyr/readme/README.html)
    tidyr (https://tidyr.tidyverse.org/)
    forcats (https://forcats.tidyverse.org/)
    Cairo (https://cran.r-project.org/web/packages/Cairo/index.html)

If these libraries are not installed, the tool will attempt to install them.

To use this module place all BUSCO short summary files (short_summary.[generic|specific].dataset.label.txt) in a single directory, and provide
this directory PATH to this module.

The resulting plots will be written in the same directory where the short summary files are present.

You can find both the resulting R script for customisation (if so desired) and the resulting figure in the format requested in the specified directory.

MAIN DEPENDENCY: R (https://www.r-project.org/)
####################################################################################################
""")

def _set_args():
    """
    This function sets the parameters provided by the user
    """
    description_text = dedent(f"""
####################################################################################################
ARAMAYO_LAB
BUSCO_Plot
{copyright}
{authors}
{usage}
""")

    parser = argparse.ArgumentParser(
        description=description_text,
        formatter_class=RawTextHelpFormatter,
        add_help=False,
    )

    required = parser.add_argument_group("required arguments")
    optional = parser.add_argument_group("optional arguments")

    required.add_argument(
        "-wd",
        "--working_directory",
        metavar="PATH",
        required=True,
        dest="working_directory",
        help="Define the location of the working directory where the Busco files are located",
    )
    required.add_argument(
        "-l",
        "--lineage",
        required=False,
        choices=["Eukaryotic Lineage", "Metazoan Lineage"],
        default="Eukaryotic Lineage",
        dest="defined_lineage",
        help="Define the lineage used when running Busco. Default is 'Eukaryotic Lineage'. Choose between 'Eukaryotic Lineage' or 'Metazoan Lineage'."
    )
    optional.add_argument(
        "-f",
        "--file_type",
        choices=["jpeg", "png", "tiff"],
        default="jpeg",
        required=False,
        dest="output_file_type",
        help="select the output file format desired: 'jpeg', 'png', or 'tiff'",
    )
    optional.add_argument(
        "-rt",
        "--run_type",
        required=False,
        dest="run_type",
        help="type of summary to use, `generic` or `specific`",
    )
    optional.add_argument(
        "--no_r",
        action="store_true",
        dest="no_r",
        help="To avoid to run R. It will just create the R script file in the working directory",
    )
    optional.add_argument(
        "-q",
        "--quiet",
        action="store_true",
        dest="quiet",
        help="Disable the info logs, displays only errors",
    )
    optional.add_argument(
        "-h",
        "--help",
        action="help",
        help="Show this help message and exit"
    )

    args = vars(parser.parse_args())

    global _plot_dir
    _plot_dir = args["working_directory"]

    global _lineage
    _lineage = args["defined_lineage"]

    global _file_type
    _file_type = args["output_file_type"]

    global _run_type
    _run_type = "[generic|specific]*"

    if args["run_type"]:
        _run_type = args["run_type"]

    if args["no_r"]:
        global _no_r
        _no_r = True

    if args["quiet"]:
        _logger.setLevel(logging.ERROR)

    if _plot_dir[-1] != "/":
        _plot_dir += "/"

    ####################################################################################################
    # Print the arguments for testing
    for arg, value in args.items():
        print(f"{arg}: {value}")

    # Exit the script to prevent further execution
    #sys.exit()
    ####################################################################################################

def _check_wd():
    """
    This function checks that the working directory exists with write permission
    :raises SystemExit: if the folder is absent or the user has no write permission
    """
    if not os.path.exists(_plot_dir):
        _logger.warning("Impossible to read %s" % _plot_dir)
        raise SystemExit()
    if not os.access(_plot_dir, os.W_OK):
        _logger.warning("Impossible to write into %s" % _plot_dir)
        raise SystemExit()

#: working directory
_plot_dir = ""

####################################################################################################
# Code imported from the original BuscoLogger.py file
class Busco_Plot_Logger(logging.getLoggerClass()):
    """
    This class customizes the _logger class
    """

    _level = logging.DEBUG
    _has_warning = False
    warn_output = io.StringIO()
    ppid = str(os.getppid())
    pid = str(os.getpid())

    def __init__(self, name):
        """
        :param name: the name of the Busco_Plot_Logger instance to be created
        :type name: str
        """
        super(Busco_Plot_Logger, self).__init__(name)
        self.setLevel(Busco_Plot_Logger._level)
        self._normal_formatter = logging.Formatter(
            "%(asctime)s %(levelname)s:\t%(message)s", datefmt="%Y-%m-%d %H:%M:%S"
        )
        self._verbose_formatter = logging.Formatter(
            "%(asctime)s %(levelname)s:%(name)s\t%(message)s",
            datefmt="%Y-%m-%d %H:%M:%S",
        )
        self._external_formatter = logging.Formatter("%(message)s")

        self._out_hdlr = logging.StreamHandler(sys.stdout)
        self._out_hdlr.addFilter(LessThanFilter(logging.ERROR))
        self._out_hdlr.setLevel(logging.INFO)
        self._out_hdlr.setFormatter(self._normal_formatter)
        self.addHandler(self._out_hdlr)

        self._err_hdlr = logging.StreamHandler()
        self._err_hdlr.setLevel(logging.ERROR)
        self._err_hdlr.setFormatter(self._normal_formatter)
        self.addHandler(self._err_hdlr)

        try:
            # Identify main log file with process ID and have all spawned processes log to the correct file
            log_filename = "Busco_Plot_{}.log".format(type(self).ppid)
            if not os.path.exists(log_filename):
                log_filename = "Busco_Plot_{}.log".format(type(self).pid)

            # Process id used in filename to avoid complications for parallel BUSCO runs.
            self._file_hdlr = logging.FileHandler(log_filename, mode="a")
        except IOError as e:
            errStr = (
                "No permission to write in the current directory: {}".format(
                    os.getcwd()
                )
                if e.errno == 13
                else "IO error({0}): {1}".format(e.errno, e.strerror)
            )
            raise BatchFatalError(errStr)

        self._file_hdlr.setLevel(logging.DEBUG)
        self._file_hdlr.setFormatter(self._verbose_formatter)
        self.addHandler(self._file_hdlr)

        self._warn_hdlr = logging.StreamHandler(type(self).warn_output)
        self._warn_hdlr.setLevel(logging.WARNING)
        self._warn_hdlr.setFormatter(self._verbose_formatter)
        self.addHandler(self._warn_hdlr)

    def __call__(self):
        pass

    @classmethod
    def reset(cls):
        cls._level = logging.DEBUG
        cls._has_warning = False
        cls.warn_output = io.StringIO()
        return

    @staticmethod
    def get_logger(name, config=None):
        """
        :param name: the name of the logger to be returned
        :type name: str
        :param config: the parameters of the analysis
        :type config: PipeConfig
        :return: a Busco_Plot_Logger, new or existing, corresponding to the provided name
        :rtype: Busco_Plot_Logger
        """
        try:
            if config and config.getboolean("busco_run", "quiet"):
                Busco_Plot_Logger._level = logging.ERROR
        except NoOptionError:
            pass
        except NoSectionError:
            pass

        logging.setLoggerClass(Busco_Plot_Logger)
        return logging.getLogger(name)

    def warn(self, msg, *args, **kwargs):
        """
        This function redirects the obsolete logging class method "warn"
        :param msg: the message to log
        :type msg: str
        """
        self.warning(msg, *args, **kwargs)

    def warning(self, msg, *args, **kwargs):
        """
        This function overrides the _logger class warning
        :param msg: the message to log
        :type msg: str
        """
        type(self)._has_warning = True
        super().warning(msg, *args, **kwargs)

    def has_warning(self):
        """
        :return: whether any _logger encountered any log warnings
        :rtype: boolean
        """
        return type(self)._has_warning

# Code from https://stackoverflow.com/a/31459386/4844311
class LessThanFilter(logging.Filter):
    def __init__(self, exclusive_maximum, name=""):
        super(LessThanFilter, self).__init__(name)
        self.max_level = exclusive_maximum

    def filter(self, record):
        # non-zero return means we log this message
        return 1 if record.levelno < self.max_level else 0

####################################################################################################
# Code imported from the original 'Exceptions.py' Python code file.
class BatchFatalError(Exception):
    """
    Error that prevents batch mode from running.
    """

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value

class Busco_Plot_Error(Exception):
    """
    Module-specific exception
    """

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return self.value
####################################################################################################
#: Get an instance of _logger for keeping track of events
_logger = Busco_Plot_Logger.get_logger(__name__)

#: r file name
_r_file = "Busco_Plot_Figure.R"

# to avoid running R
_no_r = False

RCODE = (
    "######################################\n"
    "#\n"
    "# BUSCO summary figure\n"
    "# @version 4.0.0\n"
    "# @since BUSCO 2.0.0\n"
    "# \n"
    "# Copyright (c) 2016-2022, Evgeny Zdobnov (ez@ezlab.org)\n"
    "# Licensed under the MIT license. See LICENSE.md file.\n"
    "# Modified by Rodolfo Aramayo\n"
    "# 2024-04-05\n"
    "#\n"
    "######################################\n"
    "\n"
    "# Code modified from: https://vbaliga.github.io/posts/2019-04-28-verify-that-r-packages-are-installed-and-loaded/\n"
    "# If a package is installed, it will be loaded.\n"
    "# If any package are missing, the missing package(s) will be installed\n"
    "# from CRAN and then loaded.\n"
    "# First specify the packages of interest\n"
    "## First specify the packages of interest\n"
    'packages = c("Cairo", "ggplot2", "grid")\n'
    "\n"
    "## Now load or install&load all\n"
    "package.check <- lapply(packages, FUN = function(x) \n"
    "{if (!require(x, character.only = TRUE)) {install.packages(x, dependencies = TRUE);\n"
    "library(x, character.only = TRUE)}})\n"
    "# Load the required libraries\n"
    "library(Cairo)\n"
    "library(ggplot2)\n"
    'library("grid")\n'
    'suppressPackageStartupMessages(library(dplyr))\n'
    'suppressPackageStartupMessages(library(tidyr))\n'
    'suppressPackageStartupMessages(library(forcats))\n'
    'suppressPackageStartupMessages(library(Cairo))\n'
    "\n"
    "# !!! CONFIGURE YOUR PLOT HERE !!! \n"
    "# Output\n"
    'my_file_type <- "%s7"\n'
    'my_output <- paste(%s1,"Busco_Plot_Figure.%s7", sep="/") \n'
    "my_width <- 20\n"
    "my_height <- 15\n"
    'my_unit <- "cm"\n'
    "\n"
    "# Colors\n"
    'my_colors <- c("#56B4E9", "#3492C7", "#F0E442", "#F04442")\n'
    "# Bar height ratio\n"
    "my_bar_height <- 0.75\n"
    "\n"
    "# Legend\n"
    'my_title <- "BUSCO Assessment Results"\n'
    'my_subtitle <- "%s6"\n'
    "# Font\n"
    'my_family <- "sans"\n'
    "my_size_ratio <- 1\n"
    "\n"
    "# !!! SEE YOUR DATA HERE !!! \n"
    "# Your data as generated by python, remove or add more\n"
    "my_species <- c%s2\n"
    "#my_species <- factor(my_species)\n"
    "#my_species <- factor(my_species, levels = levels(my_species)[c(length(levels(my_species)):1)])\n"
    "# reorder your species here just by changing the values in the vector :\n"
    "my_percentage <- c%s3\n"
    "my_values <- c%s4\n"
    "\n"
    "######################################\n"
    "######################################\n"
    "# Code to produce the graph\n"
    "labsize = 1\n"
    "if (length(my_species) > 10){\n"
    " labsize = 0.66\n"
    "}\n"
    'print("Plotting the figure ...")\n'
    'category <- c(rep(c("S","D","F","M"),c%s5))\n'
    "#category <- factor(category)\n"
    "#category <- factor(category,levels(category)[c(4,1,2,3)])\n"
    "df <- data.frame(my_species,my_percentage,my_values,category)\n"
    'df <- df |>\n'
    '  pivot_wider(\n'
    '  id_cols = my_species,\n'
    '  names_from = category,\n'
    '  values_from = c(my_percentage, my_values)\n'
    '  ) |>\n'
    '  arrange(\n'
    '    my_values_M,\n'
    '    my_values_F,\n'
    '    my_values_D,\n'
    '    my_values_S\n'
    '    ) |>\n'
    '    pivot_longer(\n'
    '      cols = !my_species,\n'
    '      names_to = c(".value", "category"),\n'
    '      names_pattern = "^(my_percentage|my_values)_([MFDS])$"\n'
    '    ) |>\n'
    '    mutate(my_species = factor(x = my_species, levels = rev(unique(my_species)))) |>\n'
    '    mutate(category = factor(x = category, levels = c("S", "D", "F", "M")))\n'
    'my_species <- df$my_species\n'
    'my_values <- df$my_values\n'
    "figure <- ggplot() + \n"
    "  \n"
    '  geom_bar(aes(y = my_percentage, x = fct_rev(fct_inorder(my_species)), fill = category), position = position_stack(reverse = TRUE), data = df, stat="identity", '
    "width=my_bar_height) + \n"
    "  coord_flip() + \n"
    "  theme_gray(base_size = 8) + \n"
    '  scale_y_continuous(labels = c("0","20","40","60","80","100"), breaks = c(0,20,40,60,80,100)) + \n'
    '  scale_fill_manual(values = my_colors,labels =c(" Complete (C) and single-copy (S)  ",\n'
    '                                                 " Complete (C) and duplicated (D)",\n'
    '                                                 " Fragmented (F)  ",\n'
    '                                                 " Missing (M)")) +   \n'
    '  ggtitle(my_title, subtitle = my_subtitle) + \n'
    '  xlab("") + \n'
    '  ylab("\\n%BUSCOs") + \n'
    "\n" +
    "  theme(" +
    "    plot.background = element_rect(fill='transparent', color = NA)," +
    "    plot.title = element_text(family=my_family, hjust=0.5, colour = 'black', size = rel(2)*my_size_ratio, face = 'bold')," +
    "    plot.subtitle = element_text(family=my_family, hjust=0.5, colour = 'black', size = rel(1.45)*my_size_ratio, face = 'bold')," +
    "    legend.background = element_rect(fill='transparent', color = NA)," +
    "    legend.box.background = element_rect(fill='transparent', color = NA)," +
    "    legend.key = element_rect(fill = 'transparent', colour=NA)," +
    "    legend.position = 'top'," +
    "    legend.title = element_blank()," +
    "    legend.text = element_text(family=my_family, size = rel(1.05)*my_size_ratio)," +
    "    panel.background = element_rect(fill='transparent', color = NA)," +
    "    panel.grid.minor = element_blank()," +
    "    panel.grid.major = element_blank()," +
    "    axis.text.y = element_text(family=my_family, colour = 'black', size = rel(1.43)*my_size_ratio)," +
    "    axis.text.x = element_text(family=my_family, colour = 'black', size = rel(1.43)*my_size_ratio)," +
    "    axis.line = element_line(linewidth=0.78*my_size_ratio, colour = 'black')," +
    "    axis.ticks.length = unit(0.37, 'cm')," +                         # Combined the repeated 'axis.ticks.length' into a single statement
    "    axis.ticks.y = element_line(colour='white', linewidth = 0)," +   # Updated size to linewidth and set to 0 as per original logic
    "    axis.ticks.x = element_line(colour='#222222', linewidth=0.5)," + # Assuming a linewidth since size is deprecated. Adjust as needed
    "    axis.title.x = element_text(family=my_family, colour = 'black', size=rel(1.1)*my_size_ratio, face = 'bold')" +
    "  ) + \n"
    "  guides(fill = guide_legend(override.aes = list(colour = NULL))) +\n"
    "  guides(fill=guide_legend(nrow=2,byrow=TRUE))\n"
    "  \n"
    "  for(i in rev(c(1:length(levels(my_species))))){\n"
    "    detailed_values <- my_values[my_species==my_species[my_species==levels(my_species)[i]]]\n"
    "    total_buscos <- sum(detailed_values)\n"
    "    figure <- figure + \n"
    '    annotate("text", label=paste("C:", detailed_values[1] + detailed_values[2], " [S:", detailed_values[1], '
    '", D:", detailed_values[2], "], F:", detailed_values[3], ", M:", detailed_values[4], ", n:", total_buscos, '
    'sep=""), \n'
    '             y=3, x = i, size = labsize*3.45*my_size_ratio, colour = "black", hjust=0, family=my_family)\n'
    "  }\n"
    "  \n"
    'CairoFonts(\n'
    '  regular = "sans:style=Regular",\n'
    '  bold = "sans:style=Bold",\n'
    '  italic = "sans:style=Italic"\n'
    ')\n'
    'Cairo(\n'
    '  width = my_width,\n'
    '  height = my_height,\n'
    '  file = my_output,\n'
    '  type = "%s7",\n'
    '  dpi = 500,\n'
    '  res = NA,\n'
    '  units = my_unit,\n'
    '  bg = "transparent"\n'
    ')\n'
    'grid.draw(figure)\n'
    'dev.off()\n'
    'print("Done")\n'
)

def _write_r_code(data):
    """
    This function write the R code in its own file
    :param data: the data loaded from the run folders used to generate the R file
    :type data: dict
    """
    r_file = open("%s%s" % (_plot_dir, _r_file), "w")
    r_file.write(
        RCODE.replace("%s1", '"%s"' % _plot_dir)
        .replace("%s2", str(tuple(data["species"])))
        .replace("%s3", str(tuple(data["percentages"])))
        .replace("%s4", str(tuple(data["values"])))
        .replace("%s5", "(1)")
        # Additional options specific to project
        .replace("%s6", str(data["lineage"]))
        .replace("%s7", str(data["file_type"]))
    )

def _run_r_code():
    """
    This function runs the R code after it was generated
    It first checks that ggplot2 related libraries are present
    """
    # first try to load the two required package and warn the user if an error occur
    # package ggplot2
    need_to_exit = False
    ggplot2 = subprocess.Popen(
        ["R", "-e", "library(ggplot2)", "--quiet"],
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
    )
    ggplot2_out = ggplot2.stderr.readlines() + ggplot2.stdout.readlines()
    if "Error" in str(ggplot2_out):
        _logger.warning(
            "Impossible to run R. The package ggplot2 does not seem to be installed. "
            "Please check your R installation. See also the --no_r option to avoid this message"
        )
        need_to_exit = True

    # package grid
    grid = subprocess.Popen(
        ["R", "-e", "library(grid)", "--quiet"],
        stderr=subprocess.PIPE,
        stdout=subprocess.PIPE,
    )

    grid_out = grid.stderr.readlines() + grid.stdout.readlines()
    if "Error" in str(grid_out):
        _logger.warning(
            "Impossible to run R. The package grid does not seem to be installed. "
            "Please check your R installation. See also the --no_r option to avoid this message"
        )
        need_to_exit = True

    if need_to_exit:
        return None  # do not run the code, but no need to stop the execution

    # run R
    if which("Rscript") is not None:
        r_script = ["Rscript", "%s%s" % (_plot_dir, _r_file)]
        p = subprocess.Popen(
            r_script, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        out, err = p.communicate()
        if out:
            _logger.info("\n%s" % str(out.decode("utf-8")))
        if err:
            _logger.error("\n%s" % str(err.decode("utf-8")))
    else:
        _logger.error('"Rscript" is not accessible')
        raise SystemExit()

def _load_data():
    """
    Load data based on the provided lineage.

    :param lineage: The lineage used when running Busco.
    :return: The loaded data.
    """
    data = {"species": [], "values": [], "percentages": [], "species_tmp": [], "lineage": _lineage, "file_type": _file_type}

    datasets = set([])

    for f in glob.glob("%s/short_summary.%s.*.*.txt" % (_plot_dir, _run_type)):
        try:
            datasets.add(f.split("/")[-1].split(".")[1])
            content = open(f)
            comp = 0
            dupl = 0
            frag = 0
            miss = 0
            for line in content:
                if "Complete and single-copy BUSCOs" in line:
                    comp = int(line.split("\t")[1])
                elif "Complete and duplicated BUSCOs" in line:
                    dupl = int(line.split("\t")[1])
                elif "Fragmented BUSCOs" in line:
                    frag = int(line.split("\t")[1])
                elif "Missing BUSCOs" in line:
                    miss = int(line.split("\t")[1])
            data["species_tmp"] += [
                ".".join(
                    f.split("/")[-1].split(".")[3:-1] + [f.split("/")[-1].split(".")[2]]
                )
            ] * 4
            data["values"] += [comp, dupl, frag, miss]
            total = comp + dupl + frag + miss
            comp_pc = round(comp / float(total) * 100, 1)
            dupl_pc = round(dupl / float(total) * 100, 1)
            frag_pc = round(frag / float(total) * 100, 1)
            miss_pc = round(100 - comp_pc - dupl_pc - frag_pc, 1)
            data["percentages"] += [comp_pc, dupl_pc, frag_pc, miss_pc]
            _logger.info("Loaded %s successfully" % f)
        except IOError:
            _logger.warning("Impossible to use the file %s" % f)
    # if only one dataset, remove it from species label
    if len(datasets) == 1:
        data["species"] = [label.split(".")[0]
            for label in data["species_tmp"]]
    else:
        data["species"] = data["species_tmp"]
    if len(data["species"]) == 0:
        _logger.warning(
            "No files matching the pattern short_summary.%s were found in %s"
            % (_run_type, _plot_dir)
        )
        raise SystemExit()

    return data

def main():
    """
    This function produces a figure with all BUSCO runs present in the current folder
    """

    _set_args()  # Fetch the params provided by the user
    start_time = time.time()

    try:

        _logger.info(
            "****************** Start plot generation at %s ******************"
            % (time.strftime("%m/%d/%Y %H:%M:%S"))
        )

        # check working directory
        _check_wd()
        # load data
        _logger.info("Load data ...")
        data = _load_data()

        # write R code
        _logger.info("Generate the R code ...")
        _write_r_code(data)

        # run R code
        if not _no_r:
            _logger.info("Run the R code ...")
            _run_r_code()
        else:
            _logger.info("You chose not to run R")

        if not _logger.has_warning():
            _logger.info(
                "Plot generation done. Total running time: %s seconds"
                % str(time.time() - start_time)
            )
        else:
            _logger.info(
                "Plot generation done with WARNING(s). Total running time: %s seconds"
                % str(time.time() - start_time)
            )
        _logger.info("Results written in %s\n" % _plot_dir)

    except SystemExit:
        _logger.error("Plot generation failed !")
        _logger.info(
            "Check the logs, read the user guide, and check the BUSCO issue board on https://gitlab.com/ezlab/busco/issues"
        )
        raise

    except KeyboardInterrupt:
        _logger.error("A signal was sent to kill the process")
        _logger.error("Plot generation failed !")
        _logger.info(
            "Check the logs, read the user guide, and check the BUSCO issue board on https://gitlab.com/ezlab/busco/issues"
        )
        raise

    except BaseException:
        exc_type, exc_value, exc_traceback = sys.exc_info()
        _logger.critical(
            "Unhandled exception occurred: %s"
            % repr(traceback.format_exception(exc_type, exc_value, exc_traceback))
        )
        _logger.error("Plot generation failed !\n")
        _logger.info(
            "Check the logs, read the user guide, and check the BUSCO issue board on https://gitlab.com/ezlab/busco/issues"
        )
        raise SystemExit()

# Entry point
if __name__ == "__main__":
    main()
